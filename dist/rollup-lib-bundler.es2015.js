/*! @comandeer/rollup-lib-bundler v0.17.0 | (c) 2023 Comandeer | MIT license (see LICENSE) */
import{join as t,extname as n,basename as r,dirname as o,resolve as e}from"path";import{rimraf as s}from"rimraf";import i from"console-control-strings";import{Console as a}from"console";import{Writable as c,Duplex as u}from"stream";import l from"@comandeer/cli-spinner";import{existsSync as p,readFileSync as f}from"fs";import{rollup as m}from"rollup";import d from"@rollup/plugin-commonjs";import g from"rollup-plugin-dts";import h from"@rollup/plugin-terser";import w from"@rollup/plugin-json";import y from"@rollup/plugin-babel";import b from"@babel/preset-env";import j from"@rollup/plugin-typescript";const $=Symbol("stdout"),W=Symbol("stderr"),x=Symbol("spinner");class E{constructor({stdout:t=process.stdout,stderr:n=process.stderr}={}){if(!S(t))throw new TypeError("Custom stdout must be a valid writable/duplex stream");if(!S(n))throw new TypeError("Custom stderr must be a valid writable/duplex stream");this[$]=t,this[W]=n,this.console=new a({stdout:t,stderr:n}),this[x]=new l({label:"Working…",stdout:n}),this.pendingLogs=[],this.pendingWarnings=[]}async showSpinner(){return this[x].show()}async hideSpinner(){return this[x].hide()}addLog(...t){this.pendingLogs.push(t)}addWarning(t){if((n=t)&&"object"==typeof n&&"UNRESOLVED_IMPORT"===n.code)return;var n;const r=function(t){t&&"object"==typeof t&&t.message&&(t=t.message);return`${i.color(["yellow","bold"])}⚠️ Warning!⚠️ ${t}${i.color("reset")}`}(t);this.pendingWarnings.push([r])}display(){this.pendingWarnings.forEach((t=>{this.console.warn(...t)})),this.pendingLogs.forEach((t=>{this.console.log(...t)}))}displayError(t){const n=function({name:t,message:n,stack:r}){const o=r.split("\n");o.shift();const e=o.join("\n");return`${i.color(["bold","red"])}🚨Error🚨\n${t}: ${n}${i.color("reset")}\n${e}`}(t);this.console.error(n)}}function S(t){return t instanceof c||t instanceof u}let v;async function k(n){if("string"!=typeof n)throw new TypeError("Provide a path to a package directory.");const r=function(n){const r=t(n,"package.json");if(!p(r))throw new ReferenceError("The package.json does not exist in the provided location.");const o=f(r,"utf8");let e;try{e=JSON.parse(o)}catch(t){throw new SyntaxError("The package.json file is not parsable as a correct JSON.")}return e}(n);return function(t){function n(n){if(void 0===t[n])throw new ReferenceError(`Package metadata must contain "${n}" property.`)}function r(...n){if(!n.some((n=>{const r=n.split("/");return o(t,r)})))throw new ReferenceError(`Package metadata must contain one of ${e(n)} properties or all of them.`)}function o(t,n){const r=n.shift();return void 0!==t[r]&&(0===n.length||o(t[r],n))}function e(t){return t.map(((r,o)=>{const e=`"${n(r)}"`;if(0===o)return e;return`${o===t.length-1?" or ":", "}${e}`})).join("");function n(t){const n=/(\/)/g;return t.split(n).reduce(((t,n)=>{const r=t[t.length-1];return n.startsWith(".")&&"."===r?[...t.slice(0,-1),"[ '",n]:"/"===n&&r.startsWith(".")?[...t,"' ]."]:"/"===n?[...t,"."]:[...t,n]}),[]).join("")}}n("name"),n("version"),r("exports/./import","exports/import","module","jsnext:main"),n("author"),n("license")}(r),async function(t,n){return{name:n.name,version:n.version,author:L(n.author),license:n.license,dist:await O(t,n)}}(n,r)}function L(t){return"object"!=typeof t?String(t):t.name}async function O(r,o){const e=function(t){const n=t.exports;if(!n)return["."];const r=Object.keys(n).filter((t=>t.startsWith(".")));r.includes(".")||r.unshift(".");return r}(o),s=await Promise.all(e.map((e=>async function(r,o,e){const s=await async function(r,o){if(!v){const t=await import("globby");v=t.globby}const e=t(r,"src"),s="."===o?"index":o,i=`${s}.{mts,ts,mjs,js,cts,cjs}`,a=await v(i,{cwd:e});return function(t){const r=[".mts",".ts",".mjs",".js",".cts",".cjs"],o=t.sort(((t,o)=>r.indexOf(n(t))-r.indexOf(n(o))));return o[0]}(a)}(r,e),i=t("src",s),a=function(t,n){const r=C(t,n,"import");if("."===n)return r||t.module||t["jsnext:main"];return r}(o,e),c=function(t,n){const r=C(t,n,"require");if("."===n)return r||t.main;return r}(o,e),u=function(t){const n=t.toLowerCase().endsWith("ts");return n?"ts":"js"}(i),l={esm:a,type:u};c&&(l.cjs=c);if("ts"===u){const t=function(t,n){const r=C(t,n,"types");if("."===n)return r||t.types;return r}(o,e),n=await async function(t){const n="tsconfig?(.rlb).json",r=await v(n,{cwd:t});if(0===r.length)return null;const o=r.find((t=>t.endsWith(".rlb.json")))||r[0];return o}(r);t&&(l.types=t),n&&(l.tsConfig=n)}return{[i]:l}}(r,o,e))));return s.reduce(((t,n)=>({...t,...n})),{})}function C(t,n,r){if(!t.exports)return null;const o=t.exports;return o[n]?o[n][r]:o[n]||"."!==n?null:o[r]}const P=">=16.0.0".replace(/[<=>~^]/g,"");let T;async function F({onWarn:t,packageInfo:n}){if(!T){const t=await import("globby");T=t.globby}await Promise.all(function(t,n=(()=>{})){const s=Object.entries(t.dist);return s.map((([s,i])=>async function(t,n,s,{onWarn:i=(()=>{})}={}){const a=(f=t,`/*! ${f.name} v${f.version} | (c) ${(new Date).getFullYear()} ${f.author} | ${f.license} license (see LICENSE) */`),c=function(t,n,r=(()=>{})){const o=[d(),w(),{renderDynamicImport:()=>({left:"import(",right:");"})},y({babelrc:!1,babelHelpers:"bundled",presets:[[b,{targets:{node:P}}]]}),h()];"ts"===n.type&&o.splice(2,0,j({tsconfig:!!n.tsConfig&&n.tsConfig}));return{input:t,onwarn:r,plugins:o}}(n,s,i),u=I(s.esm,a,"esm"),l=await m(c),p=[l.write(u)];var f;if(s.cjs){const t=I(s.cjs,a,"cjs");p.push(l.write(t))}else i(`Skipping CJS build for ${n}`);await Promise.all(p),s.types&&await async function({sourceFile:t,outputFile:n,onWarn:s=(()=>{})}={}){const i={input:u(),plugins:[g()],onwarn:s},a={file:n,format:"es"},c=await m(i);function u(){const s=`${r(t,".ts")}.d.ts`,i=o(n);return e(i,s)}await c.write(a)}({sourceFile:n,outputFile:s.types,onWarn:i})}(t,s,i,{onWarn:n})))}(n,t)),await async function(t){const n=Object.entries(t.dist),r=n.reduce(((t,[,n])=>(n.types&&t.push(n.types),t)),[]);if(0===r.length)return;const e=o(r[0]),i=(await T(["**/*.d.ts"],{cwd:e,absolute:!0})).filter((t=>!r.includes(t)));return s(i)}(n)}function I(t,n,r="esm"){return{banner:n,sourcemap:!0,format:r,file:t,exports:"auto"}}async function R(){const t=new E;try{await t.showSpinner();const n=process.cwd(),r=e(n,"dist");await s(r);const o=await k(n);await F({onWarn(n){t.addWarning(n)},packageInfo:o}),t.addLog(`${i.color(["bold","green"])}Bundling complete!${i.color("reset")}`)}catch(n){t.displayError(n),t.addLog(`${i.color(["bold","red"])}Bundling failed!${i.color("reset")}`)}finally{await t.hideSpinner(),t.display()}}export{R as default};
//# sourceMappingURL=rollup-lib-bundler.es2015.js.map
