/*! @comandeer/rollup-lib-bundler v0.18.0 | (c) 2023 Comandeer | MIT license (see LICENSE) */
import{join as t,extname as r,normalize as o,resolve as e,dirname as n}from"node:path";import{rimraf as s}from"rimraf";import i from"console-control-strings";import{Console as a}from"node:console";import{Writable as c,Duplex as l}from"node:stream";import p from"@comandeer/cli-spinner";import{access as u,readFile as f,mkdir as m,writeFile as d}from"node:fs/promises";import{rollup as w}from"rollup";import g from"@rollup/plugin-commonjs";import h from"rollup-plugin-dts";import y from"@rollup/plugin-terser";import b from"@rollup/plugin-json";import j from"@rollup/plugin-babel";import v from"@babel/preset-env";import $ from"@rollup/plugin-typescript";import E from"typescript";const W=Symbol("stdout"),k=Symbol("stderr"),x=Symbol("spinner");class S{constructor({stdout:t=process.stdout,stderr:r=process.stderr}={}){if(!P(t))throw new TypeError("Custom stdout must be a valid writable/duplex stream");if(!P(r))throw new TypeError("Custom stderr must be a valid writable/duplex stream");this[W]=t,this[k]=r,this.console=new a({stdout:t,stderr:r}),this[x]=new p({label:"Workingâ€¦",stdout:r}),this.pendingLogs=[],this.pendingWarnings=[]}async showSpinner(){return this[x].show()}async hideSpinner(){return this[x].hide()}addLog(...t){this.pendingLogs.push(t)}addWarning(t){if((r=t)&&"object"==typeof r&&"UNRESOLVED_IMPORT"===r.code)return;var r;const o=function(t){t&&"object"==typeof t&&t.message&&(t=t.message);return`${i.color(["yellow","bold"])}âš ï¸ Warning!âš ï¸ ${t}${i.color("reset")}`}(t);this.pendingWarnings.push([o])}display(){this.pendingWarnings.forEach((t=>{this.console.warn(...t)})),this.pendingLogs.forEach((t=>{this.console.log(...t)}))}displayError(t){const r=function({name:t,message:r,stack:o}){const e=o.split("\n");e.shift();const n=e.join("\n");return`${i.color(["bold","red"])}ðŸš¨ErrorðŸš¨\n${t}: ${r}${i.color("reset")}\n${n}`}(t);this.console.error(r)}}function P(t){return t instanceof c||t instanceof l}let C;async function O(r){if("string"!=typeof r)throw new TypeError("Provide a path to a package directory.");const o=await async function(r){const o=t(r,"package.json");try{await u(o)}catch{throw new ReferenceError("The package.json does not exist in the provided location.")}const e=await f(o,"utf8");let n;try{n=JSON.parse(e)}catch(t){throw new SyntaxError("The package.json file is not parsable as a correct JSON.")}return n}(r);return function(t){var r,o,e;if(void 0===t.name)throw new ReferenceError('Package metadata must contain "name" property.');if(void 0===t.version)throw new ReferenceError('Package metadata must contain "version" property.');if(void 0===(null===(r=t.exports)||void 0===r?void 0:r.import)&&void 0===(null===(o=t.exports)||void 0===o||null===(e=o["."])||void 0===e?void 0:e.import))throw new ReferenceError('Package metadata must contain one of "exports[ \'.\' ].import" or "exports.import" properties or all of them.');if(void 0===t.author)throw new ReferenceError('Package metadata must contain "author" property.');if(void 0===t.license)throw new ReferenceError('Package metadata must contain "license" property.')}(o),async function(t,r){return{project:t,name:r.name,version:r.version,author:L(r.author),license:r.license,dist:await R(t,r)}}(r,o)}function L(t){return"object"!=typeof t?String(t):t.name}async function R(o,e){const n=function(t){const r=t.exports,o=Object.keys(r).filter((t=>t.startsWith(".")));o.includes(".")||o.unshift(".");return o}(e),s=await Promise.all(n.map((n=>async function(o,e,n){const s=await async function(o,e){if(!C){const t=await import("globby");C=t.globby}const n=t(o,"src"),s="."===e?"index":e,i=`${s}.{mts,ts,mjs,js,cts,cjs}`,a=await C(i,{cwd:n});return function(t){const o=[".mts",".ts",".mjs",".js",".cts",".cjs"],e=t.sort(((t,e)=>o.indexOf(r(t))-o.indexOf(r(e))));return e[0]}(a)}(o,n),i=t("src",s),a=function(t,r){const o=T(t,r,"import");return o}(e,n),c=function(t,r){const o=T(t,r,"require");return o}(e,n),l=function(t){const r=t.toLowerCase().endsWith("ts");return r?"ts":"js"}(i),p={esm:a,type:l};c&&(p.cjs=c);if("ts"===l){const t=function(t,r){const o=T(t,r,"types");return o}(e,n),r=await async function(t){const r="tsconfig?(.rlb).json",o=await C(r,{cwd:t});if(0===o.length)return null;const e=o.find((t=>t.endsWith(".rlb.json")))||o[0];return e}(o);t&&(p.types=t),r&&(p.tsConfig=r)}return{[i]:p}}(o,e,n))));return s.reduce(((t,r)=>({...t,...r})),{})}function T(t,r,o){const e=t.exports;return e[r]?e[r][o]:e[r]||"."!==r?null:e[o]}const D=">=16.0.0".replace(/[<=>~^]/g,"");let F,I;async function N({onWarn:t,packageInfo:r}){if(!F){const t=await import("globby");F=t.globby}if(!I){const t=await import("tempy");I=t.temporaryDirectoryTask}await Promise.all(function(t,r=(()=>{})){const s=Object.entries(t.dist);return s.map((([s,i])=>async function(t,r,s,{onWarn:i=(()=>{})}={}){const a=(f=t,`/*! ${f.name} v${f.version} | (c) ${(new Date).getFullYear()} ${f.author} | ${f.license} license (see LICENSE) */`),c=function(t,r,o=(()=>{})){const e=[g(),b(),{renderDynamicImport:()=>({left:"import(",right:");"})},j({babelrc:!1,babelHelpers:"bundled",presets:[[v,{targets:{node:D}}]]}),y()];"ts"===r.type&&e.splice(2,0,$({tsconfig:!!r.tsConfig&&r.tsConfig,declaration:!1}));return{input:t,onwarn:o,plugins:e}}(r,s,i),l=J(s.esm,a,"esm"),p=await w(c),u=[p.write(l)];var f;if(s.cjs){const t=J(s.cjs,a,"cjs");u.push(p.write(t))}else i(`Skipping CJS build for ${r}`);await Promise.all(u),s.types&&await async function({project:t,sourceFile:r,outputFile:s,onWarn:i=(()=>{})}={}){return t=o(t),I((async r=>{r=o(r);const l=(await F("src/**/*.ts",{absolute:!0,cwd:t})).map((t=>o(t))),p={declaration:!0,emitDeclarationOnly:!0},u={};delete p.declarationDir;const f=E.createCompilerHost(p);f.writeFile=(t,r)=>{const e=o(t);u[e]=r};E.createProgram(l,p,f).emit();const g=Object.entries(u).map((async([t,o])=>{const s=c(t),i=e(r,s),a=n(i);return await m(a,{recursive:!0}),d(i,o,{encoding:"utf-8",flag:"w"})}));await Promise.all(g);const y={input:a(r),plugins:[{resolveId:t=>t.startsWith(r)?t:null},h()],onwarn:i},b={file:s,format:"es"},j=await w(y);await j.write(b)}));function a(t){const o=c(r).replace(/\.ts$/,".d.ts");return e(t,o)}function c(r){return o(r).replace(t,"").replace(/^[/\\]/,"")}}({project:t.project,sourceFile:r,outputFile:s.types,tsConfig:s.tsConfig,onWarn:i})}(t,s,i,{onWarn:r})))}(r,t))}function J(t,r,o="esm"){return{banner:r,sourcemap:!0,format:o,file:t,exports:"auto"}}async function B(){const t=new S;try{await t.showSpinner();const r=process.cwd(),o=e(r,"dist");await s(o);const n=await O(r);await N({onWarn(r){t.addWarning(r)},packageInfo:n}),t.addLog(`${i.color(["bold","green"])}Bundling complete!${i.color("reset")}`)}catch(r){t.displayError(r),t.addLog(`${i.color(["bold","red"])}Bundling failed!${i.color("reset")}`)}finally{await t.hideSpinner(),t.display()}}export{B as default};
//# sourceMappingURL=rollup-lib-bundler.es2015.js.map
