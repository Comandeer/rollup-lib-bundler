/*! @comandeer/rollup-lib-bundler v0.16.1 | (c) 2022 Comandeer | MIT license (see LICENSE) */
import{join as r,resolve as n}from"path";import t from"rimraf";import e from"console-control-strings";import{Console as o}from"console";import{Writable as s,Duplex as i}from"stream";import a from"@comandeer/cli-spinner";import{existsSync as c,readFileSync as u}from"fs";import{rollup as l}from"rollup";import p from"@rollup/plugin-commonjs";import{terser as f}from"rollup-plugin-terser";import m from"@rollup/plugin-json";import d from"@rollup/plugin-babel";import h from"@babel/preset-env";const g=Symbol("stdout"),w=Symbol("stderr"),b=Symbol("spinner");class y{constructor({stdout:r=process.stdout,stderr:n=process.stderr}={}){if(!$(r))throw new TypeError("Custom stdout must be a valid writable/duplex stream");if(!$(n))throw new TypeError("Custom stderr must be a valid writable/duplex stream");this[g]=r,this[w]=n,this.console=new o({stdout:r,stderr:n}),this[b]=new a({label:"Working…",stdout:n}),this.pendingLogs=[],this.pendingWarnings=[]}async showSpinner(){return this[b].show()}async hideSpinner(){return this[b].hide()}addLog(...r){this.pendingLogs.push(r)}addWarning(r){if((n=r)&&"object"==typeof n&&"UNRESOLVED_IMPORT"===n.code)return;var n;const t=function(r){r&&"object"==typeof r&&r.message&&(r=r.message);return`${e.color(["yellow","bold"])}⚠️ Warning!⚠️ ${r}${e.color("reset")}`}(r);this.pendingWarnings.push([t])}display(){this.pendingWarnings.forEach((r=>{this.console.warn(...r)})),this.pendingLogs.forEach((r=>{this.console.log(...r)}))}displayError(r){const n=function({name:r,message:n,stack:t}){const o=t.split("\n");o.shift();const s=o.join("\n");return`${e.color(["bold","red"])}🚨Error🚨\n${r}: ${n}${e.color("reset")}\n${s}`}(r);this.console.error(n)}}function $(r){return r instanceof s||r instanceof i}function j(r){if("string"==typeof r)r=function(r){if(!c(r))throw new ReferenceError("File with given path does not exist.");const n=u(r,"utf8");let t;try{t=JSON.parse(n)}catch(r){throw new SyntaxError("Given file is not parsable as a correct JSON.")}return t}(r);else if("object"!=typeof r)throw new TypeError("Provide string or object.");return function(r){function n(n){if(void 0===r[n])throw new ReferenceError(`Package metadata must contain "${n}" property.`)}function t(...n){if(!n.some((n=>{const t=n.split("/");return e(r,t)})))throw new ReferenceError(`Package metadata must contain one of ${o(n)} properties or all of them.`)}function e(r,n){const t=n.shift();return void 0!==r[t]&&(0===n.length||e(r[t],n))}function o(r){return r.map(((t,e)=>{const o=`"${n(t)}"`;if(0===e)return o;return`${e===r.length-1?" or ":", "}${o}`})).join("");function n(r){const n=/(\/)/g;return r.split(n).reduce(((r,n)=>{const t=r[r.length-1];return n.startsWith(".")&&"."===t?[...r.slice(0,-1),"[ '",n]:"/"===n&&t.startsWith(".")?[...r,"' ]."]:"/"===n?[...r,"."]:[...r,n]}),[]).join("")}}n("name"),n("version"),t("exports/./import","exports/import","module","jsnext:main"),n("author"),n("license")}(r),function(r){return{name:r.name,version:r.version,author:v(r.author),license:r.license,dist:E(r)}}(r)}function v(r){return"object"!=typeof r?String(r):r.name}function E(n){const t=function(r){const n=r.exports;if(!n)return["."];const t=Object.keys(n).filter((r=>r.startsWith(".")));t.includes(".")||t.unshift(".");return t}(n);return t.reduce(((t,e)=>{const o=function(n,t){const e="."===t?"index":t,o=e.endsWith(".js")?e:`${e}.js`,s=r("src",o),i=function(r,n){const t=S(r,n,"import");if("."===n)return t||r.module||r["jsnext:main"];return t}(n,t),a=function(r,n){const t=S(r,n,"require");if("."===n)return t||r.main;return t}(n,t),c={esm:i};a&&(c.cjs=a);return{[s]:c}}(n,e);return{...t,...o}}),{})}function S(r,n,t){if(!r.exports)return null;const e=r.exports;return e[n]?e[n][t]:e[n]||"."!==n?null:e[t]}const W=">=16.0.0".replace(/[<=>~^]/g,"");async function x({onWarn:r,packageInfo:n}){await Promise.all(function(r,n=(()=>{})){return Object.entries(r.dist).map((([t,e])=>async function(r,n,t,{onWarn:e=(()=>{})}={}){const o=(u=r,`/*! ${u.name} v${u.version} | (c) ${(new Date).getFullYear()} ${u.author} | ${u.license} license (see LICENSE) */`),s=function(r,n=(()=>{})){const t=[p(),m(),{renderDynamicImport:()=>({left:"import(",right:");"})},d({babelrc:!1,babelHelpers:"bundled",presets:[[h,{targets:{node:W}}]]}),f()];return{input:r,onwarn:n,plugins:t}}(n,e),i=k(t.esm,o,"esm"),a=await l(s),c=[a.write(i)];var u;if(t.cjs){const r=k(t.cjs,o,"cjs");c.push(a.write(r))}else e(`Skipping CJS build for ${n}`);await Promise.all(c)}(r,t,e,{onWarn:n})))}(n,r))}function k(r,n,t="esm"){return{banner:n,sourcemap:!0,format:t,file:r,exports:"auto"}}async function L(){const r=new y;try{await r.showSpinner();const s=n(process.cwd(),"dist");await(o=s,new Promise(((r,n)=>{t(o,(t=>{if(t)return n(t);r()}))})));const i=j("package.json");await x({onWarn(n){r.addWarning(n)},packageInfo:i}),r.addLog(`${e.color(["bold","green"])}Bundling complete!${e.color("reset")}`)}catch(n){r.displayError(n),r.addLog(`${e.color(["bold","red"])}Bundling failed!${e.color("reset")}`)}finally{await r.hideSpinner(),r.display()}var o}export{L as default};
//# sourceMappingURL=rollup-lib-bundler.es2015.js.map
