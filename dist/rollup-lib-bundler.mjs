/*! @comandeer/rollup-lib-bundler v0.20.0 | (c) 2023 Comandeer | MIT license (see LICENSE) */
import{rimraf as t}from"rimraf";import e from"console-control-strings";import{Console as r}from"node:console";import{Writable as n,Duplex as o}from"node:stream";import s from"@comandeer/cli-spinner";import{access as i,readFile as a,chmod as c}from"node:fs/promises";import{globby as l}from"globby";import{join as u,normalize as p,extname as f,dirname as d,relative as m,resolve as g}from"pathe";import h from"@babel/plugin-syntax-import-assertions";import w from"@babel/preset-env";import y from"@rollup/plugin-babel";import b from"@rollup/plugin-commonjs";import v from"@rollup/plugin-json";import j from"@rollup/plugin-terser";import W from"@rollup/plugin-typescript";import{rollup as $}from"rollup";import x from"rollup-plugin-preserve-shebang";import E from"rollup-plugin-dts";import k from"@rollup/plugin-virtual";import S from"typescript";import{transformAsync as _}from"@babel/core";import*as C from"@babel/types";import{fileURLToPath as L}from"url";const D=Symbol("stdout"),O=Symbol("stderr"),I=Symbol("spinner");class P{constructor({stdout:t=process.stdout,stderr:e=process.stderr}={}){if(!F(t))throw new TypeError("Custom stdout must be a valid writable/duplex stream");if(!F(e))throw new TypeError("Custom stderr must be a valid writable/duplex stream");this[D]=t,this[O]=e,this.console=new r({stdout:t,stderr:e}),this[I]=new s({label:"Workingâ€¦",stdout:e}),this.pendingLogs=[],this.pendingWarnings=[]}async showSpinner(){return this[I].show()}async hideSpinner(){return this[I].hide()}addLog(...t){this.pendingLogs.push(t)}addWarning(t){if((r=t)&&"object"==typeof r&&"UNRESOLVED_IMPORT"===r.code)return;var r;const n=function(t){t&&"object"==typeof t&&t.message&&(t=t.message);return`${e.color(["yellow","bold"])}âš ï¸ Warning!âš ï¸ ${t}${e.color("reset")}`}(t);this.pendingWarnings.push([n])}display(){this.pendingWarnings.forEach((t=>{this.console.warn(...t)})),this.pendingLogs.forEach((t=>{this.console.log(...t)}))}displayError(t){const r=function({name:t,message:r,stack:n}){const o=n.split("\n");o.shift();const s=o.join("\n");return`${e.color(["bold","red"])}ðŸš¨ErrorðŸš¨\n${t}: ${r}${e.color("reset")}\n${s}`}(t);this.console.error(r)}}function F(t){return t instanceof n||t instanceof o}async function R(t){if("string"!=typeof t)throw new TypeError("Provide a path to a package directory.");const e=await async function(t){const e=u(t,"package.json");try{await i(e)}catch{throw new ReferenceError("The package.json does not exist in the provided location.")}const r=await a(e,"utf8");let n;try{n=JSON.parse(r)}catch(t){throw new SyntaxError("The package.json file is not parsable as a correct JSON.")}return n}(t);return function(t){var e,r,n;if(void 0===t.name)throw new ReferenceError('Package metadata must contain "name" property.');if(void 0===t.version)throw new ReferenceError('Package metadata must contain "version" property.');if(void 0===(null===(e=t.exports)||void 0===e?void 0:e.import)&&void 0===(null===(r=t.exports)||void 0===r||null===(n=r["."])||void 0===n?void 0:n.import))throw new ReferenceError('Package metadata must contain one of "exports[ \'.\' ].import" or "exports.import" properties or all of them.');if(void 0===t.author)throw new ReferenceError('Package metadata must contain "author" property.');if(void 0===t.license)throw new ReferenceError('Package metadata must contain "license" property.')}(e),async function(t,e){const r=p(t);return{project:r,name:e.name,version:e.version,author:N(e.author),license:e.license,dist:await T(t,e)}}(t,e)}function N(t){return"object"!=typeof t?String(t):t.name}async function T(t,e){const r=function(t){const e=t.exports,r=Object.keys(e).filter((t=>t.startsWith(".")));r.includes(".")||r.unshift(".");const n=function({bin:t,name:e}){if(void 0===t)return[];if("string"==typeof t)return[`./__bin__/${e}`];const r=Object.keys(t).map((t=>`./__bin__/${t}`));return r}(t);return r.push(...n),r}(e),n=await Promise.all(r.map((r=>async function(t,e,r){const n=await async function(t,e){const r=u(t,"src"),n="."===e?"index":e,o=`${n}.{mts,ts,mjs,js,cts,cjs}`,s=await l(o,{cwd:r});return function(t){const e=[".mts",".ts",".mjs",".js",".cts",".cjs"],r=t.sort(((t,r)=>e.indexOf(f(t))-e.indexOf(f(r))));return r[0]}(s)}(t,r),o=u("src",n),s=function(t){return t.startsWith("./__bin__")}(r),i=s?function({bin:t,name:e},r){const n=/^\.\/__bin__\//g,o=r.replace(n,"");if(o===e&&"string"==typeof t)return t;return t[o]}(e,r):function(t,e){const r=B(t,e,"import");return r}(e,r),a=function(t,e){const r=B(t,e,"require");return r}(e,r),c=function(t){const e=t.toLowerCase().endsWith("ts");return e?"ts":"js"}(o),p={esm:i,type:c,isBin:s};a&&(p.cjs=a);if("ts"===c){const n=function(t,e){const r=B(t,e,"types");return r}(e,r),o=await async function(t){const e="tsconfig?(.rlb).json",r=await l(e,{cwd:t});if(0===r.length)return null;const n=r.find((t=>t.endsWith(".rlb.json")))||r[0];return n}(t);n&&(p.types=n),o&&(p.tsConfig=o)}return{[o]:p}}(t,e,r))));return[...n].reduce(((t,e)=>({...t,...e})),{})}function B(t,e,r){const n=t.exports;return n[e]?n[e][r]:n[e]||"."!==e?void 0:n[r]}function J(t){const e="\0virtual:src";return{resolveId(r,n){var o;if(!n)return null;const s=d(n),i=/\.(m|c)?js$/,a=(null===(o=r.match(i))||void 0===o?void 0:o[0])??"";r.endsWith(".d.ts")||(r=`${r.replace(i,"")}.d.ts`);const c=u(s,r),l=c.replace(e,"./dist"),p=function(t,e){return Object.entries(t).some((([,{types:t}])=>t===e))}(t,l);if(!p)return c;const f=n.replace(e,"./dist"),g=d(f);return{id:`./${m(g,l).replace(/\.d\.ts$/,a)}`,external:!0}}}}async function q({packageInfo:t,sourceFile:e,outputFile:r,tsConfig:n,onWarn:o=(()=>{})}={}){const s=t.project,i=function(t,e){if(!e)return{};const r=g(t,e),n=S.readConfigFile(r,S.sys.readFile),o=S.parseJsonConfigFileContent(n.config,S.sys,t);return o.options}(s,n),a={...i,declaration:!0,emitDeclarationOnly:!0};delete a.outDir,delete a.declarationDir,delete a.outFile,delete a.rootDir;const c=await l("src/**/*.{cts,mts,ts}",{absolute:!0,cwd:s}),u={},p=S.createCompilerHost(a);p.writeFile=(t,e)=>{const r=A(s,t);u[r]=e};S.createProgram(c,a,p).emit();const f=function(t,e){const r=/\.(c|m)?ts$/,n=A(t,e).replace(r,".d.$1ts");return n}(s,e),d={input:f,plugins:[J(t.dist),k(u),E()],onwarn:o},m={file:r,format:"es"},h=await $(d);await h.write(m)}function A(t,e){return e.replace(t,"").replace(/^[/\\]/,"")}function H(t,e){return{name:"rlb-resolve-other-bundles",async resolveId(r,n){if(!r.startsWith("."))return null;const o=(await this.resolve(r,n,{skipSelf:!0})).id,s=m(t,o);if(!(void 0!==e[s]))return null;return{id:`rlb:${s}`,external:!0}},async renderChunk(r,n,{file:o}){const s=g(t,o),{code:i,map:a}=await _(r,{plugins:[M(t,e,s)]});return{code:i,map:a}}}}function M(t,e,r){return{visitor:{ImportDeclaration(t){const{node:e}=t,{value:r}=e.source;if(!r.startsWith("rlb:"))return;const o=n(r,"esm");t.replaceWith(C.importDeclaration(e.specifiers,C.stringLiteral(o)))},ExportNamedDeclaration(t){const{node:e}=t,{source:r}=e;if(!r||!r.value.startsWith("rlb:"))return;const o=n(r.value,"esm");t.replaceWith(C.exportNamedDeclaration(e.declaration,e.specifiers,C.stringLiteral(o)))},ExportAllDeclaration(t){const{node:e}=t,{source:r}=e;if(!r.value.startsWith("rlb:"))return;const o=n(r.value,"esm");t.replaceWith(C.exportAllDeclaration(C.stringLiteral(o)))},CallExpression(t){const{node:e}=t,{callee:r,arguments:o}=e;if(!C.isIdentifier(r)||"require"!==r.name)return;const[s]=o;if(!C.isStringLiteral(s))return;const i=s.value;if(!i.startsWith("rlb:"))return;const a=n(i,"cjs");t.replaceWith(C.callExpression(C.identifier("require"),[C.stringLiteral(a)]))}}};function n(n,o){const s=n.slice(4),i=e[s][o],a=g(t,i),c=d(r),l=m(c,a);return l.startsWith(".")?l:`./${l}`}}const U=(V=import.meta.url,d(L(V)));var V;const Y=g(U,"..","package.json"),z=await a(Y,"utf8"),{engines:G}=JSON.parse(z),K=G.node.replace(/[<=>~^]/g,"");async function Q({onWarn:t,packageInfo:e}){await Promise.all(function(t,e=(()=>{})){const r=Object.entries(t.dist);return r.map((([r,n])=>async function(t,e,r,{onWarn:n=(()=>{})}={}){const o=(u=t,`/*! ${u.name} v${u.version} | (c) ${(new Date).getFullYear()} ${u.author} | ${u.license} license (see LICENSE) */`),s=function(t,e,r,n=(()=>{})){const o=[b(),v(),H(t.project,t.dist),{renderDynamicImport:()=>({left:"import(",right:");"})},y({babelrc:!1,babelHelpers:"bundled",plugins:[h],presets:[[w,{targets:{node:K}}]],extensions:[".js",".mjs",".cjs",".ts",".mts",".cts"]}),x(),j()];"ts"===r.type&&o.splice(3,0,W({tsconfig:!!r.tsConfig&&r.tsConfig,declaration:!1}));return{input:e,onwarn:n,plugins:o}}(t,e,r,n),i=X(r.esm,o,"esm"),a=await $(s),l=[a.write(i)];var u;if(r.cjs){const t=X(r.cjs,o,"cjs");l.push(a.write(t))}await Promise.all(l),r.isBin&&await async function(t,{esm:e}){const r=g(t,e);return c(r,"755")}(t.project,r);r.types&&await q({packageInfo:t,sourceFile:e,outputFile:r.types,tsConfig:r.tsConfig,onWarn:n})}(t,r,n,{onWarn:e})))}(e,t))}function X(t,e,r="esm"){return{banner:e,sourcemap:!0,format:r,file:t,exports:"auto"}}async function Z(){const r=new P;try{await r.showSpinner();const n=process.cwd(),o=await R(n),s=function({project:t,dist:e}){const r=new Set;return Object.values(e).forEach((({esm:e,cjs:n,types:o})=>{const s=g(t,e),i=d(s);if(r.add(i),n){const e=g(t,n),o=d(e);r.add(o)}if(o){const e=g(t,o),n=d(e);r.add(n)}})),[...r]}(o).filter((t=>t!==o.project));await t(s),await Q({onWarn(t){r.addWarning(t)},packageInfo:o}),r.addLog(`${e.color(["bold","green"])}Bundling complete!${e.color("reset")}`)}catch(t){r.displayError(t),r.addLog(`${e.color(["bold","red"])}Bundling failed!${e.color("reset")}`)}finally{await r.hideSpinner(),r.display()}}export{Z as default};
//# sourceMappingURL=rollup-lib-bundler.mjs.map
