/*! @comandeer/rollup-lib-bundler v0.27.0 | (c) 2025 Comandeer | MIT license (see LICENSE) */
import{rimraf as t}from"rimraf";import e from"chalk";import n from"@babel/plugin-syntax-import-assertions";import r from"@babel/preset-env";import o from"@rollup/plugin-babel";import i from"@rollup/plugin-json";import s from"@rollup/plugin-terser";import a from"@rollup/plugin-typescript";import{rollup as c}from"rollup";import p from"rollup-plugin-preserve-shebang";import u from"@rollup/plugin-virtual";import{globby as l}from"globby";import{extname as f,dirname as d,join as m,resolve as g,relative as y,normalize as h}from"pathe";import w from"rollup-plugin-dts";import b from"typescript";import v from"magic-string";import{chmod as j,access as x,readFile as E}from"node:fs/promises";import{Console as $}from"node:console";import{stderr as k,stdout as W}from"node:process";import S from"@comandeer/cli-spinner";import _ from"semver";import C from"node:assert/strict";const O="\0virtual:",F=new RegExp(`^${O}`);function P(t,e,{isTypeBundling:n=!1}={}){return{name:"rlb-resolve-other-bundles",async resolveId(r,o){if(!r.startsWith(".")||"string"!=typeof o)return null;const i=n?function(t,e){const n=f(t),r=n.replace(/js$/,"ts"),o=new RegExp(`${n}$`),i=t.replace(o,`${r}`),s=t.replace(o,`.d${r}`),a=e.replace(F,""),c=d(a),p=m(c,s),u=m(c,i);return{id:`${O}${p}`,tsSourceFilePath:u}}(r,o):await this.resolve(r,o,{skipSelf:!0}),s=function(t,e,n){if(n&&"tsSourceFilePath"in e)return e.tsSourceFilePath;return y(t,e.id)}(t,i,n),a=function(t,e,n){const r=e[t],o=void 0!==r;if(!n)return o;return o&&void 0!==r.types}(s,e,n);if(!a)return n?i.id:null;return{id:`rlb:${s}`,external:!0}},async renderChunk(n,r,{file:o}){const i=g(t,o),s=new v(n);s.replaceAll(/(?:import|export).+?from\s*["'](rlb:.+?)["']/g,((n,r)=>{const o=function(e,n,r){const o=e.slice(4),i=n[o].esm,s=g(t,i),a=d(r),c=y(a,s);return c.startsWith(".")?c:`./${c}`}(r,e,i);return n.replace(r,o)}));return{code:s.toString(),map:s.generateMap()}}}}async function R({packageMetadata:t,sourceFile:e,outputFile:n,tsConfig:r,onWarn:o=(()=>{})}){const i=t.project,s=function(t,e){if(void 0===e)return{};const n=g(t,e),r=b.readConfigFile(n,b.sys.readFile);return b.parseJsonConfigFileContent(r.config,b.sys,t).options}(i,r),a={...s,declaration:!0,emitDeclarationOnly:!0};delete a.outDir,delete a.declarationDir,delete a.outFile,delete a.rootDir;const p=await l("src/**/*.{cts,mts,ts}",{absolute:!0,cwd:i}),f={},d=b.createCompilerHost(a);d.writeFile=(t,e)=>{const n=L(i,t);f[n]=e};b.createProgram(p,a,d).emit();const m=function(t,e){const n=/\.(c|m)?ts$/,r=L(t,e).replace(n,".d.$1ts");return r}(i,e),y={input:m,plugins:[u(f),P(i,t.dist,{isTypeBundling:!0}),w()],onwarn:o},h={file:n,format:"es"},v=await c(y);await v.write(h)}function L(t,e){return e.replace(t,"").replace(/^[/\\]/,"")}async function N({onWarn:t,packageMetadata:e}){await Promise.all(function(t,e=(()=>{})){const u=Object.entries(t.dist);return u.map((([u,l])=>async function(t,e,u,{onWarn:l=(()=>{})}={}){const f=(w=t,`/*! ${w.name} v${w.version} | (c) ${(new Date).getFullYear()} ${w.author} | ${w.license} license (see LICENSE) */`),m=function(t,e,c,u=(()=>{})){const l=[i(),P(t.project,t.dist),{name:"rlb-preserve-dynamic-imports",renderDynamicImport:()=>({left:"import(",right:");"})},o({babelrc:!1,babelHelpers:"bundled",plugins:[n],presets:[[r,{targets:{node:t.targets.node}}]],extensions:[".js",".mjs",".cjs",".ts",".mts",".cts"]}),p(),s()];if("ts"===c.type){const t=function({esm:t,tsConfig:e}){const n={tsconfig:e??!1,declaration:!1,compilerOptions:{target:"ESNext",lib:["ESNext"],module:"NodeNext",moduleResolution:"NodeNext"}};void 0!==e&&(n.compilerOptions.outDir=d(t));return n}(c);l.splice(3,0,a(t))}return{input:e,onwarn:u,plugins:l}}(t,e,u,l),y=function(t,e){return{banner:e,sourcemap:!0,format:"esm",file:t,exports:"auto"}}(u.esm,f),h=await c(m);var w;await h.write(y),u.isBin&&await async function(t,{esm:e}){const n=g(t,e);return j(n,"755")}(t.project,u);void 0!==u.types&&await R({packageMetadata:t,sourceFile:e,outputFile:u.types,tsConfig:u.tsConfig,onWarn:l})}(t,u,l,{onWarn:e})))}(e,t))}class D{#t;#e;#n;#r;constructor({console:t=new $({stdout:W,stderr:k}),spinner:e=new S({label:"Working…",stdout:k})}={}){if(!(null!==(n=t)&&"object"==typeof n&&"log"in n&&"warn"in n&&"error"in n))throw new TypeError("Custom console must be a valid Console object");var n;if(!function(t){return null!==t&&"object"==typeof t&&"show"in t&&"hide"in t}(e))throw new TypeError("Custom spinner must be a valid spinner object");this.#t=t,this.#e=e,this.#n=[],this.#r=[]}static createWarning(t){return"object"==typeof t&&void 0!==t.message&&(t=t.message),e.yellow.bold(`⚠️ Warning!⚠️ ${t}`)}static createError({name:t,message:n,stack:r}){const o=r?.split("\n")??[];o.shift();const i=o.join("\n");return`${e.red.bold(`🚨Error🚨\n${t}: ${n}`)}\n${i}`}async showSpinner(){return this.#e.show()}async hideSpinner(){return this.#e.hide()}addLog(...t){this.#n.push(t)}addWarning(t){if("object"==typeof(e=t)&&"UNRESOLVED_IMPORT"===e.code)return;var e;const n=D.createWarning(t);this.#r.push([n])}async display(){await this.hideSpinner(),this.#r.forEach((t=>{this.#t.warn(...t)})),this.#n.forEach((t=>{this.#t.log(...t)}))}async displayError(t){await this.hideSpinner();const e=D.createError(t);this.#t.error(e)}}function T(t){if(null==t)return!1;const e=Object.keys(t);return 0!==e.length&&e.every((t=>"import"===t||"types"===t||"require"===t))}function B(t){if(null==t)return!1;const e=Object.keys(t);return 0!==e.length&&e.every((t=>M(t)))}function M(t){return"string"==typeof t&&t.startsWith(".")}async function I(t){const e=g(t,"package.json");try{await x(e)}catch{throw new ReferenceError("The package.json does not exist in the provided location.")}const n=await E(e,"utf8");let r;try{r=JSON.parse(n)}catch{throw new SyntaxError("The package.json file is not parsable as a correct JSON.")}return function(t){if(void 0===t.name)throw new ReferenceError('Package metadata must contain "name" property.');if(void 0===t.version)throw new ReferenceError('Package metadata must contain "version" property.');if(!function({exports:t}){if("string"==typeof t)return!0;if(T(t))return!0;if(B(t))return!0;return!1}(t))throw new ReferenceError('Package metadata must contain at least one of "exports[ \'.\' ].import" and "exports.import" properties or the "exports" property must contain the path.');if(void 0===t.author)throw new ReferenceError('Package metadata must contain "author" property.');if(void 0===t.license)throw new ReferenceError('Package metadata must contain "license" property.')}(r),r}async function J(t,e){const n=[...A(e),...H(e)],r=await Promise.all(n.map((n=>async function(t,e,n){const r=await async function(t,e){const n=g(t,"src"),r="."===e?"index":e,o=`${r}.{mts,ts,mjs,js,cts,cjs}`,i=await l(o,{cwd:n});return function(t){const e=[".mts",".ts",".mjs",".js",".cts",".cjs"],n=t.sort(((t,n)=>e.indexOf(f(t))-e.indexOf(f(n))));return C(void 0!==n[0],"At least one entrypoint exists"),n[0]}(i)}(t,n),o=m("src",r),i=function(t){return t.startsWith("./__bin__")}(n),s=i?function({bin:t,name:e},n){const r=/^\.\/__bin__\//g,o=n.replace(r,"");if(C(void 0!==t,"Bin metadata is specified"),o===e&&"string"==typeof t)return t;return C(function(t){return"string"!=typeof t}(t),"Incorrect format of the bin property"),t[o]}(e,n):function({exports:t},e){if("string"==typeof t)return t;if(T(t)&&"."===e)return t.import;if(C(B(t),"Incorrect format of 'exports' package metadata"),C(void 0!==t[e],`Missing target for the '${e}' export`),T(t[e]))return t[e].import;return t[e]}(e,n),a=function(t){const e=f(t).toLowerCase().endsWith("ts");return e?"ts":"js"}(o),c={esm:s,type:a,isBin:i};if("ts"===a){const r=function({exports:t},e){if("string"==typeof t)return;if("."===e&&"types"in t)return t.types;if(B(t)&&T(t[e]))return t[e].types;return}(e,n),o=await async function(t){const e="tsconfig?(.rlb).json",n=await l(e,{cwd:t});if(0===n.length)return;const r=n.find((t=>t.endsWith(".rlb.json")))??n[0];return r}(t);void 0!==r&&(c.types=r),void 0!==o&&(c.tsConfig=o)}return{[o]:c}}(t,e,n))));return[...r].reduce(((t,e)=>({...t,...e})),{})}function A(t){const e=t.exports;if("string"==typeof e)return["."];const n=Object.keys(e).filter((t=>M(t)));return n.includes(".")||n.unshift("."),n}function H({bin:t,name:e}){if(void 0===t)return[];if("string"==typeof t)return[`./__bin__/${e}`];return Object.keys(t).map((t=>`./__bin__/${t}`))}async function V(t){if("string"!=typeof t)throw new TypeError("Provide a path to a package directory.");return async function(t,e){const n=h(t);return{project:n,name:e.name,version:e.version,author:q(e.author),license:e.license,dist:await J(t,e),targets:{node:U(e)}}}(t,await I(t))}function q(t){return"object"!=typeof t?String(t):t.name}function U({engines:t}){if(void 0===t?.node)return"current";try{const e=_.minVersion(t.node)?.version;return e??"current"}catch{return"current"}}async function Y(){const n=new D;try{await n.showSpinner();const r=process.cwd(),o=await V(r),i=function({project:t,dist:e}){const n=new Set;return Object.values(e).forEach((({esm:e,types:r})=>{const o=g(t,e),i=d(o);if(n.add(i),void 0!==r){const e=g(t,r),o=d(e);n.add(o)}})),[...n]}(o).filter((t=>t!==o.project));await t(i),await N({onWarn(t){n.addWarning(t)},packageMetadata:o}),n.addLog(e.green.bold("Bundling complete!"))}catch(t){await n.displayError(t),n.addLog(e.red.bold("Bundling failed!"))}finally{await n.display()}}export{Y as rlb};
//# sourceMappingURL=rollup-lib-bundler.mjs.map
