{"version":3,"file":"rollup-lib-bundler.mjs","sources":["../src/bundler/resolveDTSImportPaths.js","../src/bundler/rollupPlugins/resolveOtherBundles.js","../src/bundler/bundleTypes.js","../src/bundler/rollupPlugins/preserveDynamicImports.js","../src/generateBanner.js","../src/utils/getDirName.js","../src/targets.js","../src/bundler.js","../src/bundler/fixBinPermissions.js","../src/OutputController.js","../src/packageParser.js","../src/utils/getDistDirPaths.js","../src/index.js"],"sourcesContent":["import { dirname, join as joinPath, extname } from 'pathe';\n\nconst virtualPrefix = '\\0virtual:';\nconst virtualPrefixRegex = new RegExp( `^${ virtualPrefix }` );\n\nexport default function resolveDTSImportPaths( importee, importer ) {\n\tconst originalExtension = extname( importee );\n\tconst tsExtension = originalExtension.replace( /js$/, 'ts' );\n\tconst originalExtensionRegex = new RegExp( `${ originalExtension }$` );\n\tconst importeeWithTSExtension = importee.replace( originalExtensionRegex, `${ tsExtension }` );\n\tconst importeeWithDTSExtension = importee.replace( originalExtensionRegex, `.d${ tsExtension }` );\n\tconst importerWithoutVirtualPrefix = importer.replace( virtualPrefixRegex, '' );\n\tconst importerDir = dirname( importerWithoutVirtualPrefix );\n\tconst importeeFullPath = joinPath( importerDir, importeeWithDTSExtension );\n\tconst tsSourceFilePath = joinPath( importerDir, importeeWithTSExtension );\n\n\treturn {\n\t\tid: `${ virtualPrefix }${ importeeFullPath }`,\n\t\ttsSourceFilePath\n\t};\n}\n","import MagicString from 'magic-string';\nimport { dirname, relative as getRelativePath, resolve as resolvePath } from 'pathe';\nimport resolveDTSImportPaths from '../resolveDTSImportPaths.js';\n\nexport default function resolveOtherBundles( projectPath, metadata, {\n\tisTypeBundling = false\n} = {} ) {\n\treturn {\n\t\tname: 'rlb-resolve-other-bundles',\n\n\t\tasync resolveId( importee, importer ) {\n\t\t\tif ( !importee.startsWith( '.' ) || !importer ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst resolved = isTypeBundling ?\n\t\t\t\tresolveDTSImportPaths( importee, importer ) :\n\t\t\t\tawait this.resolve( importee, importer, {\n\t\t\t\t\tskipSelf: true\n\t\t\t\t} );\n\t\t\tconst srcPathRelativeToProject = getSrcPathRelativeToProject( projectPath, resolved, isTypeBundling );\n\t\t\tconst isBundle = checkIfBundle( srcPathRelativeToProject, metadata, isTypeBundling );\n\n\t\t\tif ( !isBundle ) {\n\t\t\t\treturn isTypeBundling ? resolved.id : null;\n\t\t\t}\n\n\t\t\tconst distPlaceholderPath = `rlb:${ srcPathRelativeToProject }`;\n\n\t\t\treturn {\n\t\t\t\tid: distPlaceholderPath,\n\t\t\t\texternal: true\n\t\t\t};\n\t\t},\n\n\t\tasync renderChunk( code, chunk, { file } ) {\n\t\t\tconst chunkFullPath = resolvePath( projectPath, file );\n\t\t\tconst magicString = new MagicString( code );\n\n\t\t\tmagicString.replaceAll( /(?:import|export).+?from\\s*[\"'](rlb:.+?)[\"']/g, ( importOrExportString, importee ) => {\n\t\t\t\tconst bundlePath = getCorrectImportPath( importee, metadata, chunkFullPath );\n\n\t\t\t\treturn importOrExportString.replace( importee, bundlePath );\n\t\t\t} );\n\n\t\t\tconst transformedCode = magicString.toString();\n\t\t\tconst map = magicString.generateMap();\n\n\t\t\treturn {\n\t\t\t\tcode: transformedCode,\n\t\t\t\tmap\n\t\t\t};\n\t\t}\n\t};\n\n\tfunction getCorrectImportPath( importee, metadata, importerFullPath ) {\n\t\tconst srcPathRelativeToProject = importee.slice( 4 );\n\t\tconst distPathRelativeToProject = metadata[ srcPathRelativeToProject ].esm;\n\t\tconst distFullPath = resolvePath( projectPath, distPathRelativeToProject );\n\t\tconst chunkDirectoryPath = dirname( importerFullPath );\n\t\tconst distPathRelativeToChunk = getRelativePath( chunkDirectoryPath, distFullPath );\n\t\tconst importPath = distPathRelativeToChunk.startsWith( '.' ) ?\n\t\t\tdistPathRelativeToChunk :\n\t\t\t`./${ distPathRelativeToChunk }`;\n\n\t\treturn importPath;\n\t}\n\n\tfunction getSrcPathRelativeToProject( projectPath, resolved, isTypeBundling ) {\n\t\tif ( isTypeBundling ) {\n\t\t\treturn resolved.tsSourceFilePath;\n\t\t}\n\n\t\treturn getRelativePath( projectPath, resolved.id );\n\t}\n\n\tfunction checkIfBundle( srcPath, metadata, isTypeBundling ) {\n\t\tconst isEntryPreset = typeof metadata[ srcPath ] !== 'undefined';\n\n\t\tif ( !isTypeBundling ) {\n\t\t\treturn isEntryPreset;\n\t\t}\n\n\t\treturn isEntryPreset && metadata[ srcPath ].types;\n\t}\n}\n","import virtual from '@rollup/plugin-virtual';\nimport { globby } from 'globby';\nimport { resolve as resolvePath } from 'pathe';\nimport { rollup } from 'rollup';\nimport dts from 'rollup-plugin-dts';\nimport ts from 'typescript';\nimport resolveOtherBundles from './rollupPlugins/resolveOtherBundles.js';\n\nexport default async function bundleTypes( {\n\tpackageInfo,\n\tsourceFile,\n\toutputFile,\n\ttsConfig,\n\tonWarn = () => {}\n} = {} ) {\n\tconst projectPath = packageInfo.project;\n\tconst userCompilerOptions = getUserCompilerOptions( projectPath, tsConfig );\n\tconst compilerOptions = {\n\t\t...userCompilerOptions,\n\t\tdeclaration: true,\n\t\temitDeclarationOnly: true\n\t};\n\n\t// Remove all options that can change the emitted output.\n\tdelete compilerOptions.outDir;\n\tdelete compilerOptions.declarationDir;\n\tdelete compilerOptions.outFile;\n\tdelete compilerOptions.rootDir;\n\n\tconst tsFiles = await globby( 'src/**/*.{cts,mts,ts}', {\n\t\tabsolute: true,\n\t\tcwd: projectPath\n\t} );\n\tconst emittedFiles = {};\n\n\tconst host = ts.createCompilerHost( compilerOptions );\n\thost.writeFile = ( filePath, contents ) => {\n\t\tconst relativeFilePath = getRelativeToProjectPath( projectPath, filePath );\n\n\t\temittedFiles[ relativeFilePath ] = contents;\n\t};\n\n\t// Prepare and emit the d.ts files\n\tconst program = ts.createProgram( tsFiles, compilerOptions, host );\n\n\tprogram.emit();\n\n\tconst input = getOriginalDTsFilePath( projectPath, sourceFile );\n\tconst rollupConfig = {\n\t\tinput,\n\t\tplugins: [\n\t\t\tvirtual( emittedFiles ),\n\n\t\t\tresolveOtherBundles( projectPath, packageInfo.dist, {\n\t\t\t\tisTypeBundling: true\n\t\t\t} ),\n\n\t\t\tdts()\n\t\t],\n\t\tonwarn: onWarn\n\t};\n\tconst outputConfig = {\n\t\tfile: outputFile,\n\t\tformat: 'es'\n\t};\n\tconst bundle = await rollup( rollupConfig );\n\n\tawait bundle.write( outputConfig );\n}\n\nfunction getUserCompilerOptions( project, tsConfig ) {\n\tif ( !tsConfig ) {\n\t\treturn {};\n\t}\n\n\tconst tsConfigFilePath = resolvePath( project, tsConfig );\n\tconst tsConfigContent = ts.readConfigFile( tsConfigFilePath, ts.sys.readFile );\n\tconst parsedOptions = ts.parseJsonConfigFileContent( tsConfigContent.config, ts.sys, project );\n\n\treturn parsedOptions.options;\n}\n\nfunction getOriginalDTsFilePath( project, sourceFile ) {\n\t// We need the relative path to the .d.(c|m)?ts file. So:\n\t// 1. Get the relative path via getRelativePath().\n\t// 2. Replace the .(c|m)?ts extension with the .d.(c|m)?ts one.\n\tconst tsExtensionRegex = /\\.(c|m)?ts$/;\n\tconst originalFilePath = getRelativeToProjectPath( project, sourceFile ).replace( tsExtensionRegex, '.d.$1ts' );\n\n\treturn originalFilePath;\n}\n\nfunction getRelativeToProjectPath( project, filePath ) {\n\t// We need the relative path to the .d.ts file. So:\n\t// 1. Remove the project path.\n\t// 2. Remove the leading slash/backslash.\n\tconst relativeFilePath = filePath.\n\t\treplace( project, '' ).\n\t\treplace( /^[/\\\\]/, '' );\n\n\treturn relativeFilePath;\n}\n","export default function preserveDynamicImports() {\n\treturn {\n\t\trenderDynamicImport() {\n\t\t\treturn {\n\t\t\t\tleft: 'import(',\n\t\t\t\tright: ');'\n\t\t\t};\n\t\t}\n\t};\n}\n","export default function generateBanner( metadata ) {\n\treturn `/*! ${metadata.name} v${metadata.version} | (c) ${new Date().getFullYear()} ${metadata.author} | ${metadata.license} license (see LICENSE) */`;\n}\n","import { fileURLToPath } from 'node:url';\nimport { dirname } from 'pathe';\n\nexport default function getDirName( url ) {\n\tconst __dirname = dirname( fileURLToPath( url ) );\n\n\treturn __dirname;\n}\n","import { readFile } from 'node:fs/promises';\nimport { resolve as resolvePath } from 'pathe';\nimport getDirName from '../src/utils/getDirName.js';\n\nconst __dirname = getDirName( import.meta.url );\nconst packageJSONFilePath = resolvePath( __dirname, '..', 'package.json' );\nconst packageJSONFileContent = await readFile( packageJSONFilePath, 'utf8' );\nconst { engines } = JSON.parse( packageJSONFileContent );\n\nconst node = engines.node.replace( /[<=>~^]/g, '' );\n\nexport { node };\n","import babelImportAssertionsPlugin from '@babel/plugin-syntax-import-assertions';\nimport babelPreset from '@babel/preset-env';\nimport babel from '@rollup/plugin-babel';\nimport convertCJS from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport terser from '@rollup/plugin-terser';\nimport typescript from '@rollup/plugin-typescript';\nimport { rollup } from 'rollup';\nimport preserveShebang from 'rollup-plugin-preserve-shebang';\nimport bundleTypes from './bundler/bundleTypes.js';\nimport fixBinPermissions from './bundler/fixBinPermissions.js';\nimport preserveDynamicImports from './bundler/rollupPlugins/preserveDynamicImports.js';\nimport resolveOtherBundles from './bundler/rollupPlugins/resolveOtherBundles.js';\nimport generateBanner from './generateBanner.js';\nimport { node as nodeTarget } from './targets.js';\n\nexport default async function bundler( {\n\tonWarn,\n\tpackageInfo\n} ) {\n\tawait Promise.all( bundleChunks( packageInfo, onWarn ) );\n}\n\nfunction bundleChunks( packageInfo, onWarn = () => {} ) {\n\tconst distInfo = Object.entries( packageInfo.dist );\n\n\treturn distInfo.map( ( [ source, output ] ) => {\n\t\treturn bundleChunk( packageInfo, source, output, { onWarn } );\n\t} );\n}\n\nasync function bundleChunk( packageInfo, source, output, { onWarn = () => {} } = {} ) {\n\tconst banner = generateBanner( packageInfo );\n\tconst inputConfig = getRollupInputConfig( packageInfo, source, output, onWarn );\n\n\tconst outputConfig = getRollupOutputConfig( output.esm, banner );\n\n\tconst bundle = await rollup( inputConfig );\n\n\tawait bundle.write( outputConfig );\n\n\tif ( output.isBin ) {\n\t\tawait fixBinPermissions( packageInfo.project, output );\n\t}\n\n\tif ( output.types ) {\n\t\tawait bundleTypes( {\n\t\t\tpackageInfo,\n\t\t\tsourceFile: source,\n\t\t\toutputFile: output.types,\n\t\t\ttsConfig: output.tsConfig,\n\t\t\tonWarn\n\t\t} );\n\t}\n}\n\nfunction getRollupInputConfig( packageInfo, input, output, onwarn = () => {} ) {\n\tconst plugins = [\n\t\tconvertCJS(),\n\n\t\tjson(),\n\n\t\tresolveOtherBundles( packageInfo.project, packageInfo.dist ),\n\n\t\tpreserveDynamicImports(),\n\n\t\tbabel( {\n\t\t\tbabelrc: false,\n\t\t\tbabelHelpers: 'bundled',\n\t\t\tplugins: [\n\t\t\t\tbabelImportAssertionsPlugin\n\t\t\t],\n\t\t\tpresets: [\n\t\t\t\t[\n\t\t\t\t\tbabelPreset,\n\t\t\t\t\t{\n\t\t\t\t\t\ttargets: {\n\t\t\t\t\t\t\tnode: nodeTarget\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t],\n\t\t\textensions: [\n\t\t\t\t'.js',\n\t\t\t\t'.mjs',\n\t\t\t\t'.cjs',\n\t\t\t\t'.ts',\n\t\t\t\t'.mts',\n\t\t\t\t'.cts'\n\t\t\t]\n\t\t} ),\n\n\t\tpreserveShebang(),\n\n\t\tterser()\n\t];\n\n\t// In case of TypeScript, we need to add the plugin.\n\t// We need to add it before the Babel plugin\n\t// and after the custom resolver, so it's at index 3.\n\t// Yep, it's not too elegantâ€¦\n\tif ( output.type === 'ts' ) {\n\t\tplugins.splice( 3, 0, typescript( {\n\t\t\ttsconfig: output.tsConfig ? output.tsConfig : false,\n\t\t\tdeclaration: false\n\t\t} ) );\n\t}\n\n\treturn {\n\t\tinput,\n\t\tonwarn,\n\t\tplugins\n\t};\n}\n\nfunction getRollupOutputConfig( outputPath, banner ) {\n\treturn {\n\t\tbanner,\n\t\tsourcemap: true,\n\t\tformat: 'esm',\n\t\tfile: outputPath,\n\t\texports: 'auto'\n\t};\n}\n","import { chmod } from 'node:fs/promises';\nimport { resolve as resolvePath } from 'pathe';\n\nexport default async function fixBinPermissions( projectPath, { esm } ) {\n\tconst binFilePath = resolvePath( projectPath, esm );\n\n\treturn chmod( binFilePath, '755' );\n}\n","import { Console } from 'node:console';\nimport { stdout, stderr } from 'node:process';\nimport Spinner from '@comandeer/cli-spinner';\nimport consoleControlStrings from 'console-control-strings';\n\nexport default class OutputController {\n\t#console;\n\t#spinner;\n\t#pendingLogs;\n\t#pendingWarnings;\n\n\tstatic createWarning( warning ) {\n\t\tif ( warning && typeof warning === 'object' && warning.message ) {\n\t\t\twarning = warning.message;\n\t\t}\n\n\t\treturn `${ consoleControlStrings.color( [ 'yellow', 'bold' ] ) }âš ï¸ Warning!âš ï¸ ${ warning }${ consoleControlStrings.color( 'reset' ) }`;\n\t}\n\n\tstatic createError( { name, message, stack } ) {\n\t\tconst stackParts = stack.split( '\\n' );\n\n\t\tstackParts.shift();\n\n\t\tconst newStack = stackParts.join( '\\n' );\n\n\t\treturn `${ consoleControlStrings.color( [ 'bold', 'red' ] ) }ðŸš¨ErrorðŸš¨\n${ name }: ${ message }${ consoleControlStrings.color( 'reset' ) }\n${ newStack }`;\n\t}\n\n\tconstructor( {\n\t\tconsole = new Console( {\n\t\t\tstdout,\n\t\t\tstderr\n\t\t} ),\n\t\tspinner = new Spinner( {\n\t\t\tlabel: 'Workingâ€¦',\n\t\t\tstdout: stderr\n\t\t} )\n\t} = {} ) {\n\t\tif ( !isValidConsole( console ) ) {\n\t\t\tthrow new TypeError( 'Custom console must be a valid Console object' );\n\t\t}\n\n\t\tif ( !isValidSpinner( spinner ) ) {\n\t\t\tthrow new TypeError( 'Custom spinner must be a valid spinner object' );\n\t\t}\n\n\t\tthis.#console = console;\n\t\tthis.#spinner = spinner;\n\t\tthis.#pendingLogs = [];\n\t\tthis.#pendingWarnings = [];\n\t}\n\n\tasync showSpinner() {\n\t\treturn this.#spinner.show();\n\t}\n\n\tasync hideSpinner() {\n\t\treturn this.#spinner.hide();\n\t}\n\n\taddLog( ...args ) {\n\t\tthis.#pendingLogs.push( args );\n\t}\n\n\taddWarning( warningMessage ) {\n\t\tif ( isExternalDepWarning( warningMessage ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst warning = OutputController.createWarning( warningMessage );\n\n\t\tthis.#pendingWarnings.push( [ warning ] );\n\t}\n\n\tdisplay() {\n\t\tthis.#pendingWarnings.forEach( ( warning ) => {\n\t\t\tthis.#console.warn( ...warning );\n\t\t} );\n\n\t\tthis.#pendingLogs.forEach( ( log ) => {\n\t\t\tthis.#console.log( ...log );\n\t\t} );\n\t}\n\n\tdisplayError( error ) {\n\t\tconst errorLog = OutputController.createError( error );\n\n\t\tthis.#console.error( errorLog );\n\t}\n}\n\n// Duck typing as checking against the Console object does not work correctly.\nfunction isValidConsole( value ) {\n\treturn value && typeof value.log === 'function' && typeof value.warn === 'function' &&\n\t\ttypeof value.error === 'function';\n}\n\nfunction isValidSpinner( value ) {\n\treturn value && typeof value.show === 'function' && typeof value.hide === 'function';\n}\n\nfunction isExternalDepWarning( log ) {\n\treturn log && typeof log === 'object' && log.code === 'UNRESOLVED_IMPORT';\n}\n","import { access, readFile } from 'node:fs/promises';\nimport { globby } from 'globby';\nimport { extname, join as joinPath, normalize as normalizePath } from 'pathe';\n\nexport default async function packageParser( packageDir ) {\n\tif ( typeof packageDir !== 'string' ) {\n\t\tthrow new TypeError( 'Provide a path to a package directory.' );\n\t}\n\n\tconst metadata = await loadAndParsePackageJSONFile( packageDir );\n\tlintObject( metadata );\n\n\treturn prepareMetadata( packageDir, metadata );\n}\n\nasync function loadAndParsePackageJSONFile( dirPath ) {\n\tconst path = joinPath( dirPath, 'package.json' );\n\n\ttry {\n\t\tawait access( path );\n\t} catch {\n\t\tthrow new ReferenceError( 'The package.json does not exist in the provided location.' );\n\t}\n\n\tconst contents = await readFile( path, 'utf8' );\n\tlet parsed;\n\n\ttry {\n\t\tparsed = JSON.parse( contents );\n\t} catch ( e ) {\n\t\tthrow new SyntaxError( 'The package.json file is not parsable as a correct JSON.' );\n\t}\n\n\treturn parsed;\n}\n\nfunction lintObject( obj ) {\n\tif ( typeof obj.name === 'undefined' ) {\n\t\tthrow new ReferenceError( 'Package metadata must contain \"name\" property.' );\n\t}\n\n\tif ( typeof obj.version === 'undefined' ) {\n\t\tthrow new ReferenceError( 'Package metadata must contain \"version\" property.' );\n\t}\n\n\tconst isESMEntryPointPresent = typeof obj.exports?.import !== 'undefined' ||\n\t\ttypeof obj.exports?.[ '.' ]?.import !== 'undefined';\n\n\tif ( !isESMEntryPointPresent ) {\n\t\tthrow new ReferenceError(\n\t\t\t'Package metadata must contain one of \"exports[ \\'.\\' ].import\" or \"exports.import\" properties or all of them.'\n\t\t);\n\t}\n\n\tif ( typeof obj.author === 'undefined' ) {\n\t\tthrow new ReferenceError( 'Package metadata must contain \"author\" property.' );\n\t}\n\n\tif ( typeof obj.license === 'undefined' ) {\n\t\tthrow new ReferenceError( 'Package metadata must contain \"license\" property.' );\n\t}\n}\n\nasync function prepareMetadata( packageDir, metadata ) {\n\tconst project = normalizePath( packageDir );\n\n\treturn {\n\t\tproject,\n\t\tname: metadata.name,\n\t\tversion: metadata.version,\n\t\tauthor: prepareAuthorMetadata( metadata.author ),\n\t\tlicense: metadata.license,\n\t\tdist: await prepareDistMetadata( packageDir, metadata )\n\t};\n}\n\nfunction prepareAuthorMetadata( author ) {\n\tif ( typeof author !== 'object' ) {\n\t\treturn String( author );\n\t}\n\n\treturn author.name;\n}\n\nasync function prepareDistMetadata( packageDir, metadata ) {\n\tconst subpaths = getSubPaths( metadata );\n\tconst subPathsMetadata = await Promise.all( subpaths.map( ( subPath ) => {\n\t\treturn prepareSubPathMetadata( packageDir, metadata, subPath );\n\t} ) );\n\tconst distMetadata = [ ...subPathsMetadata ].reduce( ( targets, currentTargets ) => {\n\t\treturn { ...targets, ...currentTargets };\n\t}, {} );\n\n\treturn distMetadata;\n}\n\nfunction getSubPaths( metadata ) {\n\tconst exports = metadata.exports;\n\n\tconst subPaths = Object.keys( exports ).filter( ( subpath ) => {\n\t\treturn subpath.startsWith( '.' );\n\t} );\n\n\tif ( !subPaths.includes( '.' ) ) {\n\t\tsubPaths.unshift( '.' );\n\t}\n\n\tconst binSubPaths = getBinSubPaths( metadata );\n\n\tsubPaths.push( ...binSubPaths );\n\n\treturn subPaths;\n}\n\nfunction getBinSubPaths( { bin, name } ) {\n\tif ( typeof bin === 'undefined' ) {\n\t\treturn [];\n\t}\n\n\tif ( typeof bin === 'string' ) {\n\t\treturn [\n\t\t\t`./__bin__/${ name }`\n\t\t];\n\t}\n\n\tconst binSubPaths = Object.keys( bin ).map( ( bin ) => {\n\t\treturn `./__bin__/${ bin }`;\n\t} );\n\n\treturn binSubPaths;\n}\n\nasync function prepareSubPathMetadata( packageDir, metadata, subPath ) {\n\tconst subPathFilePath = await getSubPathFilePath( packageDir, subPath );\n\tconst srcPath = joinPath( 'src', subPathFilePath );\n\tconst isBin = isBinSubPath( subPath );\n\tconst esmTarget = isBin ?\n\t\tgetBinTarget( metadata, subPath ) :\n\t\tgetESMTarget( metadata, subPath );\n\tconst exportType = getEntryPointType( srcPath );\n\tconst exportMetadata = {\n\t\tesm: esmTarget,\n\t\ttype: exportType,\n\t\tisBin\n\t};\n\n\tif ( exportType === 'ts' ) {\n\t\tconst typesTarget = getTypesTarget( metadata, subPath );\n\t\tconst tsConfigPath = await getTSConfigPath( packageDir );\n\n\t\tif ( typesTarget ) {\n\t\t\texportMetadata.types = typesTarget;\n\t\t}\n\n\t\tif ( tsConfigPath ) {\n\t\t\texportMetadata.tsConfig = tsConfigPath;\n\t\t}\n\t}\n\n\treturn {\n\t\t[ srcPath ]: exportMetadata\n\t};\n}\n\nasync function getSubPathFilePath( packageDir, subPath ) {\n\tconst srcPath = joinPath( packageDir, 'src' );\n\tconst subPathFileName = subPath === '.' ? 'index' : subPath;\n\tconst subPathGlobPattern = `${ subPathFileName}.{mts,ts,mjs,js,cts,cjs}`;\n\tconst matchedFiles = await globby( subPathGlobPattern, {\n\t\tcwd: srcPath\n\t} );\n\tconst desirableEntryPoint = getEntryPoint( matchedFiles );\n\n\treturn desirableEntryPoint;\n}\n\nfunction getEntryPoint( matchedFiles ) {\n\tconst fileExtensions = [\n\t\t'.mts',\n\t\t'.ts',\n\t\t'.mjs',\n\t\t'.js',\n\t\t'.cts',\n\t\t'.cjs'\n\t];\n\tconst orderedFiles = matchedFiles.sort( ( a, b ) => {\n\t\tconst aIndex = fileExtensions.indexOf( extname( a ) );\n\t\tconst bIndex = fileExtensions.indexOf( extname( b ) );\n\n\t\treturn aIndex - bIndex;\n\t} );\n\n\treturn orderedFiles[ 0 ];\n}\n\nfunction getEntryPointType( srcPath ) {\n\tconst isTS = srcPath.toLowerCase().endsWith( 'ts' );\n\n\treturn isTS ? 'ts' : 'js';\n}\n\nfunction isBinSubPath( subPath ) {\n\treturn subPath.startsWith( './__bin__' );\n}\n\nfunction getESMTarget( metadata, subPath ) {\n\tconst exportsTarget = getExportsTarget( metadata, subPath, 'import' );\n\n\treturn exportsTarget;\n}\n\nfunction getBinTarget( { bin, name }, subPath ) {\n\tconst subPathPrefixRegex = /^\\.\\/__bin__\\//g;\n\tconst binName = subPath.replace( subPathPrefixRegex, '' );\n\n\tif ( binName === name && typeof bin === 'string' ) {\n\t\treturn bin;\n\t}\n\n\treturn bin[ binName ];\n}\n\nfunction getTypesTarget( metadata, subPath ) {\n\tconst exportsTarget = getExportsTarget( metadata, subPath, 'types' );\n\n\treturn exportsTarget;\n}\n\nfunction getExportsTarget( metadata, subPath, type ) {\n\tconst exports = metadata.exports;\n\n\tif ( exports[ subPath ] ) {\n\t\treturn exports[ subPath ][ type ];\n\t}\n\n\tif ( !exports[ subPath ] && subPath === '.' ) {\n\t\treturn exports[ type ];\n\t}\n}\n\nasync function getTSConfigPath( packageDir ) {\n\tconst tsConfigGlobPattern = 'tsconfig?(.rlb).json';\n\tconst matchedFiles = await globby( tsConfigGlobPattern, {\n\t\tcwd: packageDir\n\t} );\n\n\tif ( matchedFiles.length === 0 ) {\n\t\treturn null;\n\t}\n\n\tconst rlbSpecificPath = matchedFiles.find( ( path ) => {\n\t\treturn path.endsWith( '.rlb.json' );\n\t} );\n\tconst tsConfigPath = rlbSpecificPath || matchedFiles[ 0 ];\n\n\treturn tsConfigPath;\n}\n","import { dirname, resolve as resolvePath } from 'pathe';\n\nexport default function getDistDirPaths( { project, dist } ) {\n\tconst distDirPaths = new Set();\n\tconst distFilePaths = Object.values( dist );\n\n\tdistFilePaths.forEach( ( { esm, cjs, types } ) => {\n\t\tconst esmFilePath = resolvePath( project, esm );\n\t\tconst esmDistDirPath = dirname( esmFilePath );\n\n\t\tdistDirPaths.add( esmDistDirPath );\n\n\t\tif ( cjs ) {\n\t\t\tconst cjsFilePath = resolvePath( project, cjs );\n\t\t\tconst cjsDistDirPath = dirname( cjsFilePath );\n\n\t\t\tdistDirPaths.add( cjsDistDirPath );\n\t\t}\n\n\t\tif ( types ) {\n\t\t\tconst typesFilePath = resolvePath( project, types );\n\t\t\tconst typesDistDirPath = dirname( typesFilePath );\n\n\t\t\tdistDirPaths.add( typesDistDirPath );\n\t\t}\n\t} );\n\n\treturn [ ...distDirPaths ];\n}\n","import { rimraf } from 'rimraf';\nimport consoleControlStrings from 'console-control-strings';\nimport bundler from './bundler.js';\nimport OutputController from './OutputController.js';\nimport packageParser from './packageParser.js';\nimport getDistDirPaths from './utils/getDistDirPaths.js';\n\nexport default async function rlb() {\n\tconst outputController = new OutputController();\n\n\ttry {\n\t\tawait outputController.showSpinner();\n\n\t\tconst packageDirectory = process.cwd();\n\t\tconst packageInfo = await packageParser( packageDirectory );\n\t\tconst distPaths = getDistDirPaths( packageInfo ).filter( ( distDir ) => {\n\t\t\treturn distDir !== packageInfo.project;\n\t\t} );\n\n\t\tawait rimraf( distPaths );\n\n\t\tawait bundler( {\n\t\t\tonWarn( warning ) {\n\t\t\t\toutputController.addWarning( warning );\n\t\t\t},\n\t\t\tpackageInfo\n\t\t} );\n\n\t\toutputController.addLog( `${ consoleControlStrings.color( [ 'bold', 'green' ] ) }Bundling complete!${ consoleControlStrings.color( 'reset' ) }` );\n\t} catch ( error ) {\n\t\toutputController.displayError( error );\n\t\toutputController.addLog( `${ consoleControlStrings.color( [ 'bold', 'red' ] ) }Bundling failed!${ consoleControlStrings.color( 'reset' ) }` );\n\t} finally {\n\t\tawait outputController.hideSpinner();\n\t\toutputController.display();\n\t}\n}\n"],"names":["virtualPrefix","RegExp","resolveOtherBundles","projectPath","metadata","isTypeBundling","name","async","importee","importer","startsWith","resolveId","resolved","originalExtension","resolveDTSImportPaths","tsExtension","originalExtensionRegex","replace","importeeWithTSExtension","importeeWithDTSExtension","importerWithoutVirtualPrefix","dirname","importerDir","importeeFullPath","joinPath","id","this","resolve","skipSelf","tsSourceFilePath","getSrcPathRelativeToProject","isBundle","isEntryPreset","srcPath","types","checkIfBundle","srcPathRelativeToProject","external","code","chunk","file","magicString","MagicString","resolvePath","importOrExportString","importerFullPath","slice","distPathRelativeToProject","esm","distFullPath","relative","chunkDirectoryPath","distPathRelativeToChunk","getCorrectImportPath","chunkFullPath","bundlePath","map","generateMap","bundleTypes","packageInfo","sourceFile","outputFile","tsConfig","onWarn","project","userCompilerOptions","rollupConfig","tsConfigContent","ts","readConfigFile","tsConfigFilePath","sys","readFile","parseJsonConfigFileContent","config","getUserCompilerOptions","compilerOptions","declaration","emitDeclarationOnly","outDir","outFile","globby","declarationDir","absolute","host","writeFile","filePath","contents","emittedFiles","getRelativeToProjectPath","relativeFilePath","createProgram","tsFiles","input","tsExtensionRegex","originalFilePath","getOriginalDTsFilePath","program","plugins","dist","dts","onwarn","format","bundle","rollup","write","outputConfig","url","fileURLToPath","packageJSONFilePath","__dirname","getDirName","engines","JSON","node","Promise","all","packageJSONFileContent","source","output","bundleChunks","banner","version","Date","getFullYear","author","license","inputConfig","convertCJS","json","right","babel","babelImportAssertionsPlugin","targets","extensions","babelrc","terser","type","splice","typescript","tsconfig","preserveShebang","getRollupInputConfig","outputPath","sourcemap","isBin","fixBinPermissions","bundleChunk","OutputController","console","warning","exports","message","static","stackParts","shift","newStack","join","consoleControlStrings","color","stack","stdout","stderr","spinner","Spinner","label","value","log","warn","error","Console","hide","TypeError","pendingLogs","pendingWarnings","show","addLog","args","push","addWarning","warningMessage","createWarning","forEach","isExternalDepWarning","displayError","errorLog","createError","display","packageParser","packageDir","isValidConsole","isValidSpinner","path","dirPath","loadAndParsePackageJSONFile","lintObject","parsed","parse","access","ReferenceError","_obj$exports","_obj$exports2","obj","e","import","isESMEntryPointPresent","prepareAuthorMetadata","prepareMetadata","String","subpaths","subPathsMetadata","subPaths","Object","keys","filter","subpath","distMetadata","includes","currentTargets","binSubPaths","bin","getBinSubPaths","getSubPaths","prepareDistMetadata","subPath","subPathFilePath","subPathFileName","tsConfigPath","matchedFiles","cwd","fileExtensions","getSubPathFilePath","sort","a","b","indexOf","extname","orderedFiles","getEntryPoint","aIndex","isBinSubPath","esmTarget","getEntryPointType","isTS","subPathPrefixRegex","binName","getESMTarget","exportsTarget","getBinTarget","bIndex","getExportsTarget","exportType","toLowerCase","endsWith","typesTarget","getTypesTarget","tsConfigGlobPattern","getTSConfigPath","find","exportMetadata","prepareSubPathMetadata","reduce","distDirPaths","outputController","showSpinner","process","packageDirectory","Set","cjs","esmFilePath","add","esmDistDirPath","cjsFilePath","cjsDistDirPath","typesFilePath","typesDistDirPath","getDistDirPaths","distDir","rimraf","distPaths","bundler","hideSpinner"],"mappings":"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"}